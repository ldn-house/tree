<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Christmas Tree Simulator</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #111;
      color: #fff;
      font-family: system-ui, sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      padding: 1rem;
      background: #222;
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    header h1 { font-size: 1.2rem; }
    #status {
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.8rem;
      background: #333;
    }
    #status.loading { background: #553; }
    #status.running { background: #353; }
    #status.error { background: #533; }
    .view-toggle {
      display: flex;
      gap: 0.25rem;
      background: #333;
      border-radius: 4px;
      padding: 0.2rem;
    }
    .view-toggle button {
      padding: 0.25rem 0.5rem;
      font-size: 0.8rem;
      background: transparent;
    }
    .view-toggle button.active {
      background: #555;
    }
    #coords-status {
      font-size: 0.75rem;
      color: #666;
    }
    #animation-name {
      margin-left: auto;
      font-size: 0.9rem;
      color: #aaa;
    }
    main {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 2rem;
    }
    #tree-container {
      position: relative;
      width: 400px;
      height: 500px;
    }
    #canvas-2d, #canvas-3d {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    #canvas-3d { display: none; }
    footer {
      padding: 1rem;
      background: #222;
      display: flex;
      gap: 1rem;
      align-items: center;
    }
    button {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 4px;
      background: #444;
      color: #fff;
      cursor: pointer;
    }
    button:hover { background: #555; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    select {
      padding: 0.5rem;
      border: none;
      border-radius: 4px;
      background: #444;
      color: #fff;
    }
    #fps { color: #666; margin-left: auto; font-size: 0.8rem; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
  <header>
    <h1>ðŸŽ„ Tree Simulator</h1>
    <span id="status" class="loading">Loading...</span>
    <div class="view-toggle">
      <button id="view-2d" class="active">2D</button>
      <button id="view-3d">3D</button>
    </div>
    <span id="coords-status"></span>
    <span id="animation-name"></span>
  </header>
  <main>
    <div id="tree-container">
      <canvas id="canvas-2d"></canvas>
      <canvas id="canvas-3d"></canvas>
    </div>
  </main>
  <footer>
    <button id="prev-btn" disabled>â—€ Prev</button>
    <select id="animation-select" disabled></select>
    <button id="next-btn" disabled>Next â–¶</button>
    <span id="fps"></span>
  </footer>

  <script>
    const LED_COUNT = 500;
    const canvas2d = document.getElementById('canvas-2d');
    const canvas3d = document.getElementById('canvas-3d');
    const ctx = canvas2d.getContext('2d');
    const statusEl = document.getElementById('status');
    const animNameEl = document.getElementById('animation-name');
    const selectEl = document.getElementById('animation-select');
    const fpsEl = document.getElementById('fps');
    const coordsStatusEl = document.getElementById('coords-status');

    // LED state
    let leds = new Uint8Array(LED_COUNT * 3);
    let animationNames = [];
    let currentAnimation = 0;
    let worker = null;
    let frameCount = 0;
    let lastFpsUpdate = performance.now();

    // View mode
    let viewMode = '2d';
    let coords3d = null;  // Will be loaded from coords.json

    // Three.js objects
    let scene, camera, renderer, controls;
    let ledMeshes = [];

    // Set canvas size
    function resize() {
      const container = document.getElementById('tree-container');
      const dpr = window.devicePixelRatio || 1;
      canvas2d.width = container.clientWidth * dpr;
      canvas2d.height = container.clientHeight * dpr;
      ctx.scale(dpr, dpr);

      if (renderer) {
        renderer.setSize(container.clientWidth, container.clientHeight);
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
      }
    }
    resize();
    window.addEventListener('resize', resize);

    // Load 3D coordinates
    async function loadCoordinates() {
      try {
        const resp = await fetch('coordinates/coords.json');
        if (!resp.ok) throw new Error('Not found');
        const data = await resp.json();
        coords3d = data.coordinates;
        coordsStatusEl.textContent = `3D coords: ${data.found_count}/${LED_COUNT}`;
        coordsStatusEl.style.color = '#5a5';
        return true;
      } catch (e) {
        coordsStatusEl.textContent = '3D coords: not found';
        coordsStatusEl.style.color = '#666';
        // Generate default spiral coords for demo
        coords3d = [];
        for (let i = 0; i < LED_COUNT; i++) {
          const t = i / LED_COUNT;
          const angle = t * Math.PI * 10;
          const radius = (1 - t * 0.8) * 0.8;
          coords3d.push({
            x: Math.cos(angle) * radius,
            y: t * 2 - 0.2,  // 0 to ~1.8
            z: Math.sin(angle) * radius
          });
        }
        return false;
      }
    }

    // Initialize Three.js
    function init3d() {
      const container = document.getElementById('tree-container');

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111111);

      camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 100);
      camera.position.set(3, 2, 3);

      renderer = new THREE.WebGLRenderer({ canvas: canvas3d, antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.target.set(0, 1, 0);
      controls.update();

      // Create LED spheres
      const geometry = new THREE.SphereGeometry(0.02, 8, 6);

      for (let i = 0; i < LED_COUNT; i++) {
        const material = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const mesh = new THREE.Mesh(geometry, material);

        if (coords3d && coords3d[i]) {
          mesh.position.set(coords3d[i].x, coords3d[i].y, coords3d[i].z);
        }

        scene.add(mesh);
        ledMeshes.push(mesh);
      }

      // Add subtle grid for reference
      const gridHelper = new THREE.GridHelper(4, 20, 0x333333, 0x222222);
      scene.add(gridHelper);
    }

    // Render 2D view
    function render2d() {
      const w = canvas2d.width / (window.devicePixelRatio || 1);
      const h = canvas2d.height / (window.devicePixelRatio || 1);

      ctx.fillStyle = '#111';
      ctx.fillRect(0, 0, w, h);

      const centerX = w / 2;
      const topY = 30;
      const bottomY = h - 40;
      const treeHeight = bottomY - topY;
      const maxRadius = w / 2 - 20;

      for (let i = 0; i < LED_COUNT; i++) {
        const t = i / LED_COUNT;
        const y = bottomY - t * treeHeight;
        const layerRadius = maxRadius * (1 - t * 0.85);
        const angle = t * Math.PI * 20;
        const x = centerX + Math.cos(angle) * layerRadius;

        const r = leds[i * 3];
        const g = leds[i * 3 + 1];
        const b = leds[i * 3 + 2];

        if (r > 10 || g > 10 || b > 10) {
          const gradient = ctx.createRadialGradient(x, y, 0, x, y, 8);
          gradient.addColorStop(0, `rgba(${r},${g},${b},1)`);
          gradient.addColorStop(0.5, `rgba(${r},${g},${b},0.3)`);
          gradient.addColorStop(1, `rgba(${r},${g},${b},0)`);
          ctx.fillStyle = gradient;
          ctx.fillRect(x - 8, y - 8, 16, 16);
        }

        ctx.beginPath();
        ctx.arc(x, y, 2, 0, Math.PI * 2);
        ctx.fillStyle = `rgb(${r},${g},${b})`;
        ctx.fill();
      }
    }

    // Render 3D view
    function render3d() {
      if (!renderer || ledMeshes.length === 0) return;

      // Update LED colors
      for (let i = 0; i < LED_COUNT; i++) {
        if (!ledMeshes[i]) continue;

        const r = leds[i * 3] / 255;
        const g = leds[i * 3 + 1] / 255;
        const b = leds[i * 3 + 2] / 255;

        ledMeshes[i].material.color.setRGB(r, g, b);

        // Scale based on brightness for glow effect
        const brightness = (r + g + b) / 3;
        const scale = 1 + brightness * 2;
        ledMeshes[i].scale.setScalar(scale);
      }

      controls.update();
      renderer.render(scene, camera);
    }

    // Main render loop
    function render() {
      if (viewMode === '2d') {
        render2d();
      } else {
        render3d();
      }

      frameCount++;
      const now = performance.now();
      if (now - lastFpsUpdate > 1000) {
        fpsEl.textContent = `${frameCount} fps`;
        frameCount = 0;
        lastFpsUpdate = now;
      }

      requestAnimationFrame(render);
    }

    // View toggle handlers
    document.getElementById('view-2d').onclick = () => {
      viewMode = '2d';
      document.getElementById('view-2d').classList.add('active');
      document.getElementById('view-3d').classList.remove('active');
      canvas2d.style.display = 'block';
      canvas3d.style.display = 'none';
    };

    document.getElementById('view-3d').onclick = async () => {
      viewMode = '3d';
      document.getElementById('view-3d').classList.add('active');
      document.getElementById('view-2d').classList.remove('active');
      canvas2d.style.display = 'none';
      canvas3d.style.display = 'block';

      if (!scene) {
        await loadCoordinates();
        init3d();
      }
    };

    // Worker code as blob
    const workerCode = `
      importScripts('https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js');

      let pyodide = null;
      self.speed = 1;  // Real-time speed

      const mockModules = \`
import sys

class MockPin:
    def __init__(self, pin):
        self.pin = pin

class MockNeoPixel:
    def __init__(self, pin, count):
        self.count = count
        self._leds = [(0,0,0)] * count

    def __setitem__(self, idx, color):
        if 0 <= idx < self.count:
            self._leds[idx] = color

    def __getitem__(self, idx):
        return self._leds[idx] if 0 <= idx < self.count else (0,0,0)

    def write(self):
        import js
        from pyodide.ffi import to_js
        flat = []
        for r,g,b in self._leds:
            flat.extend([int(r), int(g), int(b)])
        js.postMessage(to_js({'type': 'leds', 'data': flat}, dict_converter=js.Object.fromEntries))
        # Simulate WS2811 write time: ~30Âµs per LED = 15ms for 500 LEDs
        _real_time.sleep(0.015)

class MockMachine:
    Pin = MockPin

# Save real time module before we overwrite it
import time as _real_time

class MockTime:
    @staticmethod
    def sleep(s):
        import js
        ms = s * 1000 / js.speed
        if ms > 1:
            _real_time.sleep(ms / 1000)

    @staticmethod
    def sleep_ms(ms):
        import js
        actual_ms = ms / js.speed
        if actual_ms > 1:
            _real_time.sleep(actual_ms / 1000)

    @staticmethod
    def sleep_us(us):
        pass

    @staticmethod
    def ticks_ms():
        from js import Date
        return int(Date.now())

    @staticmethod
    def ticks_diff(a, b):
        return a - b

sys.modules['machine'] = MockMachine()
sys.modules['neopixel'] = type(sys)('neopixel')
sys.modules['neopixel'].NeoPixel = MockNeoPixel
sys.modules['time'] = MockTime()

import random
\`;

      self.speed = 5;

      self.onmessage = async (e) => {
        const { type, data } = e.data;

        if (type === 'init') {
          try {
            self.postMessage({ type: 'status', data: 'Loading Pyodide...' });
            pyodide = await loadPyodide();

            self.postMessage({ type: 'status', data: 'Initializing...' });
            await pyodide.runPythonAsync(mockModules);

            // Write 3D coordinates file to virtual filesystem
            if (data.coordsCompact) {
              pyodide.FS.writeFile('coords_compact.txt', data.coordsCompact);
              console.log('Wrote coords_compact.txt to Pyodide FS');
            }

            // Load main.py
            const mainPy = data.mainPy;
            console.log('Loading main.py:', mainPy.substring(0, 500));
            await pyodide.runPythonAsync(mainPy);
            console.log('main.py loaded successfully');

            // Get animation names
            const names = pyodide.runPython('[(name, None) for name, _ in ANIMATIONS]');
            const animNames = [];
            for (let i = 0; i < names.length; i++) {
              animNames.push(names.get(i).get(0));
            }

            self.postMessage({ type: 'animations', data: animNames });
            self.postMessage({ type: 'status', data: 'Ready' });
          } catch (err) {
            self.postMessage({ type: 'error', data: err.message });
          }
        }

        if (type === 'run') {
          const idx = data;
          try {
            await pyodide.runPythonAsync(\`
name, func = ANIMATIONS[\${idx}]
if name == "auto":
    # Auto mode: cycle through all non-auto animations
    auto_idx = 1
    while True:
        _, auto_func = ANIMATIONS[auto_idx]
        if auto_func:
            auto_func()
        auto_idx = (auto_idx % (len(ANIMATIONS) - 1)) + 1
else:
    while True:
        if func:
            func()
\`);
          } catch (err) {
            if (!err.message.includes('interrupted')) {
              self.postMessage({ type: 'error', data: err.message });
            }
          }
        }

      };
    `;

    async function loadMainPy() {
      const response = await fetch('main.py');
      let content = await response.text();

      // Replace OTA import block with simple assignment
      content = content.replace(
        /# OTA imports \(optional.*?\n.*?try:\n.*?import ota\n.*?OTA_AVAILABLE = True\nexcept ImportError:\n.*?OTA_AVAILABLE = False\n/s,
        'OTA_AVAILABLE = False\n'
      );

      // Remove WiFi/OTA setup block
      content = content.replace(
        /# Start WiFi and OTA.*?print\("Continuing without OTA\.\.\."\)\n/s,
        ''
      );

      // Remove if OTA_AVAILABLE blocks
      content = content.replace(
        /if OTA_AVAILABLE:\n        ota\.total_animations.*?\n/g,
        ''
      );
      content = content.replace(
        /            if OTA_AVAILABLE:\n                ota\.current_animation.*?\n                ota\.animation_index.*?\n/g,
        ''
      );

      // Remove the main loop at end
      content = content.replace(
        /print\("Christmas tree starting\.\.\."\)\n[\s\S]*$/,
        ''
      );

      console.log('Processed main.py length:', content.length);
      return content;
    }

    async function loadCoordsCompact() {
      // Try to load coords_compact.txt, or generate from coords.json
      try {
        const resp = await fetch('coordinates/coords_compact.txt');
        if (resp.ok) {
          return await resp.text();
        }
      } catch (e) {}

      // Generate from coords.json
      if (coords3d && coords3d.length > 0) {
        return coords3d.map(c =>
          c ? `${c.x.toFixed(4)},${c.y.toFixed(4)},${c.z.toFixed(4)}` : 'null'
        ).join('\n');
      }

      return null;
    }

    async function init() {
      statusEl.textContent = 'Loading...';
      statusEl.className = 'loading';

      const mainPy = await loadMainPy();
      const coordsCompact = await loadCoordsCompact();

      // Create worker
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      worker = new Worker(URL.createObjectURL(blob));

      worker.onmessage = (e) => {
        const { type, data } = e.data;

        if (type === 'status') {
          statusEl.textContent = data;
          if (data === 'Ready') {
            statusEl.className = 'running';
            runAnimation(currentAnimation);
          }
        }

        if (type === 'leds') {
          // Data is in GRB order (WS2811), swap back to RGB for display
          for (let i = 0; i < data.length && i < leds.length; i += 3) {
            leds[i] = data[i + 1];     // R = G position
            leds[i + 1] = data[i];     // G = R position
            leds[i + 2] = data[i + 2]; // B = B position
          }
        }

        if (type === 'animations') {
          animationNames = data;
          data.forEach((name, i) => {
            const opt = document.createElement('option');
            opt.value = i;
            opt.textContent = name;
            selectEl.appendChild(opt);
          });
          selectEl.disabled = false;
          document.getElementById('prev-btn').disabled = false;
          document.getElementById('next-btn').disabled = false;
        }

        if (type === 'error') {
          console.error(data);
          statusEl.textContent = 'Error: ' + data.slice(0, 50);
          statusEl.className = 'error';
        }

        if (type === 'animation') {
          animNameEl.textContent = data;
        }
      };

      worker.postMessage({ type: 'init', data: { mainPy, coordsCompact } });

      // Start render loop
      render();
    }

    function runAnimation(idx) {
      selectEl.value = idx;
      animNameEl.textContent = animationNames[idx] || '';
      worker.postMessage({ type: 'run', data: idx });
    }

    function switchAnimation(idx) {
      // Terminate and recreate worker to stop current animation
      if (worker) worker.terminate();
      currentAnimation = idx;
      init();
    }

    document.getElementById('prev-btn').onclick = () => {
      switchAnimation((currentAnimation - 1 + animationNames.length) % animationNames.length);
    };

    document.getElementById('next-btn').onclick = () => {
      switchAnimation((currentAnimation + 1) % animationNames.length);
    };

    selectEl.onchange = (e) => {
      switchAnimation(parseInt(e.target.value));
    };

    // URL param for animation
    const params = new URLSearchParams(location.search);
    if (params.has('anim')) {
      currentAnimation = parseInt(params.get('anim')) || 0;
    }

    // Load coordinates first (for 3D view and Python animations), then init
    loadCoordinates().then(() => init());
  </script>
</body>
</html>
